/*
eHelply SDK - 1.1.117

eHelply SDK for SuperStack Services

API version: 1.1.117
Contact: support@ehelply.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ehelply

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// MonitorApiService MonitorApi service
type MonitorApiService service

type ApiAcknowledgeAlarmRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	alarmUuid string
	alarmAcknowledge *AlarmAcknowledge
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiAcknowledgeAlarmRequest) AlarmAcknowledge(alarmAcknowledge AlarmAcknowledge) ApiAcknowledgeAlarmRequest {
	r.alarmAcknowledge = &alarmAcknowledge
	return r
}

func (r ApiAcknowledgeAlarmRequest) XAccessToken(xAccessToken string) ApiAcknowledgeAlarmRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiAcknowledgeAlarmRequest) XSecretToken(xSecretToken string) ApiAcknowledgeAlarmRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiAcknowledgeAlarmRequest) Authorization(authorization string) ApiAcknowledgeAlarmRequest {
	r.authorization = &authorization
	return r
}

func (r ApiAcknowledgeAlarmRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiAcknowledgeAlarmRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiAcknowledgeAlarmRequest) EhelplyProject(ehelplyProject string) ApiAcknowledgeAlarmRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiAcknowledgeAlarmRequest) EhelplyData(ehelplyData string) ApiAcknowledgeAlarmRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiAcknowledgeAlarmRequest) Execute() (*AlarmResponse, *http.Response, error) {
	return r.ApiService.AcknowledgeAlarmExecute(r)
}

/*
AcknowledgeAlarm Acknowledgealarm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @param alarmUuid
 @return ApiAcknowledgeAlarmRequest
*/
func (a *MonitorApiService) AcknowledgeAlarm(ctx context.Context, service string, stage string, alarmUuid string) ApiAcknowledgeAlarmRequest {
	return ApiAcknowledgeAlarmRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
		alarmUuid: alarmUuid,
	}
}

// Execute executes the request
//  @return AlarmResponse
func (a *MonitorApiService) AcknowledgeAlarmExecute(r ApiAcknowledgeAlarmRequest) (*AlarmResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlarmResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.AcknowledgeAlarm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/alarms/{alarm_uuid}/acknowledge"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alarm_uuid"+"}", url.PathEscape(parameterToString(r.alarmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.alarmAcknowledge == nil {
		return localVarReturnValue, nil, reportError("alarmAcknowledge is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.alarmAcknowledge
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignAlarmRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	alarmUuid string
	alarmAssign *AlarmAssign
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiAssignAlarmRequest) AlarmAssign(alarmAssign AlarmAssign) ApiAssignAlarmRequest {
	r.alarmAssign = &alarmAssign
	return r
}

func (r ApiAssignAlarmRequest) XAccessToken(xAccessToken string) ApiAssignAlarmRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiAssignAlarmRequest) XSecretToken(xSecretToken string) ApiAssignAlarmRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiAssignAlarmRequest) Authorization(authorization string) ApiAssignAlarmRequest {
	r.authorization = &authorization
	return r
}

func (r ApiAssignAlarmRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiAssignAlarmRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiAssignAlarmRequest) EhelplyProject(ehelplyProject string) ApiAssignAlarmRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiAssignAlarmRequest) EhelplyData(ehelplyData string) ApiAssignAlarmRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiAssignAlarmRequest) Execute() (*AlarmResponse, *http.Response, error) {
	return r.ApiService.AssignAlarmExecute(r)
}

/*
AssignAlarm Assignalarm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @param alarmUuid
 @return ApiAssignAlarmRequest
*/
func (a *MonitorApiService) AssignAlarm(ctx context.Context, service string, stage string, alarmUuid string) ApiAssignAlarmRequest {
	return ApiAssignAlarmRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
		alarmUuid: alarmUuid,
	}
}

// Execute executes the request
//  @return AlarmResponse
func (a *MonitorApiService) AssignAlarmExecute(r ApiAssignAlarmRequest) (*AlarmResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlarmResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.AssignAlarm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/alarms/{alarm_uuid}/assign"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alarm_uuid"+"}", url.PathEscape(parameterToString(r.alarmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.alarmAssign == nil {
		return localVarReturnValue, nil, reportError("alarmAssign is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.alarmAssign
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttachAlarmNoteRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	alarmUuid string
	alarmNote *AlarmNote
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiAttachAlarmNoteRequest) AlarmNote(alarmNote AlarmNote) ApiAttachAlarmNoteRequest {
	r.alarmNote = &alarmNote
	return r
}

func (r ApiAttachAlarmNoteRequest) XAccessToken(xAccessToken string) ApiAttachAlarmNoteRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiAttachAlarmNoteRequest) XSecretToken(xSecretToken string) ApiAttachAlarmNoteRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiAttachAlarmNoteRequest) Authorization(authorization string) ApiAttachAlarmNoteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiAttachAlarmNoteRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiAttachAlarmNoteRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiAttachAlarmNoteRequest) EhelplyProject(ehelplyProject string) ApiAttachAlarmNoteRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiAttachAlarmNoteRequest) EhelplyData(ehelplyData string) ApiAttachAlarmNoteRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiAttachAlarmNoteRequest) Execute() (*AlarmResponse, *http.Response, error) {
	return r.ApiService.AttachAlarmNoteExecute(r)
}

/*
AttachAlarmNote Attachalarmnote

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @param alarmUuid
 @return ApiAttachAlarmNoteRequest
*/
func (a *MonitorApiService) AttachAlarmNote(ctx context.Context, service string, stage string, alarmUuid string) ApiAttachAlarmNoteRequest {
	return ApiAttachAlarmNoteRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
		alarmUuid: alarmUuid,
	}
}

// Execute executes the request
//  @return AlarmResponse
func (a *MonitorApiService) AttachAlarmNoteExecute(r ApiAttachAlarmNoteRequest) (*AlarmResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlarmResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.AttachAlarmNote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/alarms/{alarm_uuid}/note"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alarm_uuid"+"}", url.PathEscape(parameterToString(r.alarmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.alarmNote == nil {
		return localVarReturnValue, nil, reportError("alarmNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.alarmNote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttachAlarmTicketRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	alarmUuid string
	alarmTicket *AlarmTicket
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiAttachAlarmTicketRequest) AlarmTicket(alarmTicket AlarmTicket) ApiAttachAlarmTicketRequest {
	r.alarmTicket = &alarmTicket
	return r
}

func (r ApiAttachAlarmTicketRequest) XAccessToken(xAccessToken string) ApiAttachAlarmTicketRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiAttachAlarmTicketRequest) XSecretToken(xSecretToken string) ApiAttachAlarmTicketRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiAttachAlarmTicketRequest) Authorization(authorization string) ApiAttachAlarmTicketRequest {
	r.authorization = &authorization
	return r
}

func (r ApiAttachAlarmTicketRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiAttachAlarmTicketRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiAttachAlarmTicketRequest) EhelplyProject(ehelplyProject string) ApiAttachAlarmTicketRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiAttachAlarmTicketRequest) EhelplyData(ehelplyData string) ApiAttachAlarmTicketRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiAttachAlarmTicketRequest) Execute() (*AlarmResponse, *http.Response, error) {
	return r.ApiService.AttachAlarmTicketExecute(r)
}

/*
AttachAlarmTicket Attachalarmticket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @param alarmUuid
 @return ApiAttachAlarmTicketRequest
*/
func (a *MonitorApiService) AttachAlarmTicket(ctx context.Context, service string, stage string, alarmUuid string) ApiAttachAlarmTicketRequest {
	return ApiAttachAlarmTicketRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
		alarmUuid: alarmUuid,
	}
}

// Execute executes the request
//  @return AlarmResponse
func (a *MonitorApiService) AttachAlarmTicketExecute(r ApiAttachAlarmTicketRequest) (*AlarmResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlarmResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.AttachAlarmTicket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/alarms/{alarm_uuid}/ticket"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alarm_uuid"+"}", url.PathEscape(parameterToString(r.alarmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.alarmTicket == nil {
		return localVarReturnValue, nil, reportError("alarmTicket is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.alarmTicket
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClearAlarmRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	alarmUuid string
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiClearAlarmRequest) XAccessToken(xAccessToken string) ApiClearAlarmRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiClearAlarmRequest) XSecretToken(xSecretToken string) ApiClearAlarmRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiClearAlarmRequest) Authorization(authorization string) ApiClearAlarmRequest {
	r.authorization = &authorization
	return r
}

func (r ApiClearAlarmRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiClearAlarmRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiClearAlarmRequest) EhelplyProject(ehelplyProject string) ApiClearAlarmRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiClearAlarmRequest) EhelplyData(ehelplyData string) ApiClearAlarmRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiClearAlarmRequest) Execute() (*AlarmResponse, *http.Response, error) {
	return r.ApiService.ClearAlarmExecute(r)
}

/*
ClearAlarm Clearalarm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @param alarmUuid
 @return ApiClearAlarmRequest
*/
func (a *MonitorApiService) ClearAlarm(ctx context.Context, service string, stage string, alarmUuid string) ApiClearAlarmRequest {
	return ApiClearAlarmRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
		alarmUuid: alarmUuid,
	}
}

// Execute executes the request
//  @return AlarmResponse
func (a *MonitorApiService) ClearAlarmExecute(r ApiClearAlarmRequest) (*AlarmResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlarmResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.ClearAlarm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/alarms/{alarm_uuid}/clear"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alarm_uuid"+"}", url.PathEscape(parameterToString(r.alarmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteServiceSuperStackMetaRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiDeleteServiceSuperStackMetaRequest) XAccessToken(xAccessToken string) ApiDeleteServiceSuperStackMetaRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiDeleteServiceSuperStackMetaRequest) XSecretToken(xSecretToken string) ApiDeleteServiceSuperStackMetaRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiDeleteServiceSuperStackMetaRequest) Authorization(authorization string) ApiDeleteServiceSuperStackMetaRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteServiceSuperStackMetaRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiDeleteServiceSuperStackMetaRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiDeleteServiceSuperStackMetaRequest) EhelplyProject(ehelplyProject string) ApiDeleteServiceSuperStackMetaRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiDeleteServiceSuperStackMetaRequest) EhelplyData(ehelplyData string) ApiDeleteServiceSuperStackMetaRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiDeleteServiceSuperStackMetaRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteServiceSuperStackMetaExecute(r)
}

/*
DeleteServiceSuperStackMeta Deleteservicesuperstackmeta

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @return ApiDeleteServiceSuperStackMetaRequest
*/
func (a *MonitorApiService) DeleteServiceSuperStackMeta(ctx context.Context, service string) ApiDeleteServiceSuperStackMetaRequest {
	return ApiDeleteServiceSuperStackMetaRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
	}
}

// Execute executes the request
//  @return interface{}
func (a *MonitorApiService) DeleteServiceSuperStackMetaExecute(r ApiDeleteServiceSuperStackMetaRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.DeleteServiceSuperStackMeta")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/superstack"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	heartbeats *bool
	heartbeatLimit *int32
	alarms *bool
	alarmLimit *int32
	stage *string
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiGetServiceRequest) Heartbeats(heartbeats bool) ApiGetServiceRequest {
	r.heartbeats = &heartbeats
	return r
}

func (r ApiGetServiceRequest) HeartbeatLimit(heartbeatLimit int32) ApiGetServiceRequest {
	r.heartbeatLimit = &heartbeatLimit
	return r
}

func (r ApiGetServiceRequest) Alarms(alarms bool) ApiGetServiceRequest {
	r.alarms = &alarms
	return r
}

func (r ApiGetServiceRequest) AlarmLimit(alarmLimit int32) ApiGetServiceRequest {
	r.alarmLimit = &alarmLimit
	return r
}

func (r ApiGetServiceRequest) Stage(stage string) ApiGetServiceRequest {
	r.stage = &stage
	return r
}

func (r ApiGetServiceRequest) XAccessToken(xAccessToken string) ApiGetServiceRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiGetServiceRequest) XSecretToken(xSecretToken string) ApiGetServiceRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiGetServiceRequest) Authorization(authorization string) ApiGetServiceRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetServiceRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiGetServiceRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiGetServiceRequest) EhelplyProject(ehelplyProject string) ApiGetServiceRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiGetServiceRequest) EhelplyData(ehelplyData string) ApiGetServiceRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiGetServiceRequest) Execute() (*ServiceResponse, *http.Response, error) {
	return r.ApiService.GetServiceExecute(r)
}

/*
GetService Getservice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @return ApiGetServiceRequest
*/
func (a *MonitorApiService) GetService(ctx context.Context, service string) ApiGetServiceRequest {
	return ApiGetServiceRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
	}
}

// Execute executes the request
//  @return ServiceResponse
func (a *MonitorApiService) GetServiceExecute(r ApiGetServiceRequest) (*ServiceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.heartbeats != nil {
		localVarQueryParams.Add("heartbeats", parameterToString(*r.heartbeats, ""))
	}
	if r.heartbeatLimit != nil {
		localVarQueryParams.Add("heartbeat_limit", parameterToString(*r.heartbeatLimit, ""))
	}
	if r.alarms != nil {
		localVarQueryParams.Add("alarms", parameterToString(*r.alarms, ""))
	}
	if r.alarmLimit != nil {
		localVarQueryParams.Add("alarm_limit", parameterToString(*r.alarmLimit, ""))
	}
	if r.stage != nil {
		localVarQueryParams.Add("stage", parameterToString(*r.stage, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceAlarmRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	alarmUuid string
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiGetServiceAlarmRequest) XAccessToken(xAccessToken string) ApiGetServiceAlarmRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiGetServiceAlarmRequest) XSecretToken(xSecretToken string) ApiGetServiceAlarmRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiGetServiceAlarmRequest) Authorization(authorization string) ApiGetServiceAlarmRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetServiceAlarmRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiGetServiceAlarmRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiGetServiceAlarmRequest) EhelplyProject(ehelplyProject string) ApiGetServiceAlarmRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiGetServiceAlarmRequest) EhelplyData(ehelplyData string) ApiGetServiceAlarmRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiGetServiceAlarmRequest) Execute() (*AlarmResponse, *http.Response, error) {
	return r.ApiService.GetServiceAlarmExecute(r)
}

/*
GetServiceAlarm Getservicealarm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @param alarmUuid
 @return ApiGetServiceAlarmRequest
*/
func (a *MonitorApiService) GetServiceAlarm(ctx context.Context, service string, stage string, alarmUuid string) ApiGetServiceAlarmRequest {
	return ApiGetServiceAlarmRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
		alarmUuid: alarmUuid,
	}
}

// Execute executes the request
//  @return AlarmResponse
func (a *MonitorApiService) GetServiceAlarmExecute(r ApiGetServiceAlarmRequest) (*AlarmResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlarmResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetServiceAlarm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/alarms/{alarm_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alarm_uuid"+"}", url.PathEscape(parameterToString(r.alarmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceAlarmsRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	history *int32
	includeTerminated *bool
	includeCleared *bool
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiGetServiceAlarmsRequest) History(history int32) ApiGetServiceAlarmsRequest {
	r.history = &history
	return r
}

func (r ApiGetServiceAlarmsRequest) IncludeTerminated(includeTerminated bool) ApiGetServiceAlarmsRequest {
	r.includeTerminated = &includeTerminated
	return r
}

func (r ApiGetServiceAlarmsRequest) IncludeCleared(includeCleared bool) ApiGetServiceAlarmsRequest {
	r.includeCleared = &includeCleared
	return r
}

func (r ApiGetServiceAlarmsRequest) XAccessToken(xAccessToken string) ApiGetServiceAlarmsRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiGetServiceAlarmsRequest) XSecretToken(xSecretToken string) ApiGetServiceAlarmsRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiGetServiceAlarmsRequest) Authorization(authorization string) ApiGetServiceAlarmsRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetServiceAlarmsRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiGetServiceAlarmsRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiGetServiceAlarmsRequest) EhelplyProject(ehelplyProject string) ApiGetServiceAlarmsRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiGetServiceAlarmsRequest) EhelplyData(ehelplyData string) ApiGetServiceAlarmsRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiGetServiceAlarmsRequest) Execute() ([]AlarmResponse, *http.Response, error) {
	return r.ApiService.GetServiceAlarmsExecute(r)
}

/*
GetServiceAlarms Getservicealarms

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @return ApiGetServiceAlarmsRequest
*/
func (a *MonitorApiService) GetServiceAlarms(ctx context.Context, service string, stage string) ApiGetServiceAlarmsRequest {
	return ApiGetServiceAlarmsRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
	}
}

// Execute executes the request
//  @return []AlarmResponse
func (a *MonitorApiService) GetServiceAlarmsExecute(r ApiGetServiceAlarmsRequest) ([]AlarmResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AlarmResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetServiceAlarms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/alarms"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.history != nil {
		localVarQueryParams.Add("history", parameterToString(*r.history, ""))
	}
	if r.includeTerminated != nil {
		localVarQueryParams.Add("include_terminated", parameterToString(*r.includeTerminated, ""))
	}
	if r.includeCleared != nil {
		localVarQueryParams.Add("include_cleared", parameterToString(*r.includeCleared, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceHeartbeatRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	history *int32
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiGetServiceHeartbeatRequest) History(history int32) ApiGetServiceHeartbeatRequest {
	r.history = &history
	return r
}

func (r ApiGetServiceHeartbeatRequest) XAccessToken(xAccessToken string) ApiGetServiceHeartbeatRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiGetServiceHeartbeatRequest) XSecretToken(xSecretToken string) ApiGetServiceHeartbeatRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiGetServiceHeartbeatRequest) Authorization(authorization string) ApiGetServiceHeartbeatRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetServiceHeartbeatRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiGetServiceHeartbeatRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiGetServiceHeartbeatRequest) EhelplyProject(ehelplyProject string) ApiGetServiceHeartbeatRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiGetServiceHeartbeatRequest) EhelplyData(ehelplyData string) ApiGetServiceHeartbeatRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiGetServiceHeartbeatRequest) Execute() ([]HeartbeatResponse, *http.Response, error) {
	return r.ApiService.GetServiceHeartbeatExecute(r)
}

/*
GetServiceHeartbeat Getserviceheartbeat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @return ApiGetServiceHeartbeatRequest
*/
func (a *MonitorApiService) GetServiceHeartbeat(ctx context.Context, service string, stage string) ApiGetServiceHeartbeatRequest {
	return ApiGetServiceHeartbeatRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
	}
}

// Execute executes the request
//  @return []HeartbeatResponse
func (a *MonitorApiService) GetServiceHeartbeatExecute(r ApiGetServiceHeartbeatRequest) ([]HeartbeatResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HeartbeatResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetServiceHeartbeat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/heartbeats"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.history != nil {
		localVarQueryParams.Add("history", parameterToString(*r.history, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceKpisRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	history *int32
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiGetServiceKpisRequest) History(history int32) ApiGetServiceKpisRequest {
	r.history = &history
	return r
}

func (r ApiGetServiceKpisRequest) XAccessToken(xAccessToken string) ApiGetServiceKpisRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiGetServiceKpisRequest) XSecretToken(xSecretToken string) ApiGetServiceKpisRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiGetServiceKpisRequest) Authorization(authorization string) ApiGetServiceKpisRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetServiceKpisRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiGetServiceKpisRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiGetServiceKpisRequest) EhelplyProject(ehelplyProject string) ApiGetServiceKpisRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiGetServiceKpisRequest) EhelplyData(ehelplyData string) ApiGetServiceKpisRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiGetServiceKpisRequest) Execute() ([]KpiResponse, *http.Response, error) {
	return r.ApiService.GetServiceKpisExecute(r)
}

/*
GetServiceKpis Getservicekpis

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @return ApiGetServiceKpisRequest
*/
func (a *MonitorApiService) GetServiceKpis(ctx context.Context, service string) ApiGetServiceKpisRequest {
	return ApiGetServiceKpisRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
	}
}

// Execute executes the request
//  @return []KpiResponse
func (a *MonitorApiService) GetServiceKpisExecute(r ApiGetServiceKpisRequest) ([]KpiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KpiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetServiceKpis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/kpis"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.history != nil {
		localVarQueryParams.Add("history", parameterToString(*r.history, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceSpecRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	spec string
}

func (r ApiGetServiceSpecRequest) Execute() (*GetServiceSpecResponse, *http.Response, error) {
	return r.ApiService.GetServiceSpecExecute(r)
}

/*
GetServiceSpec Getservicespec

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param spec
 @return ApiGetServiceSpecRequest
*/
func (a *MonitorApiService) GetServiceSpec(ctx context.Context, service string, spec string) ApiGetServiceSpecRequest {
	return ApiGetServiceSpecRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		spec: spec,
	}
}

// Execute executes the request
//  @return GetServiceSpecResponse
func (a *MonitorApiService) GetServiceSpecExecute(r ApiGetServiceSpecRequest) (*GetServiceSpecResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetServiceSpecResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetServiceSpec")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/specs/{spec}"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spec"+"}", url.PathEscape(parameterToString(r.spec, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAppointment403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceSpecsRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
}

func (r ApiGetServiceSpecsRequest) Execute() (*GetServiceSpecsResponse, *http.Response, error) {
	return r.ApiService.GetServiceSpecsExecute(r)
}

/*
GetServiceSpecs Getservicespecs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @return ApiGetServiceSpecsRequest
*/
func (a *MonitorApiService) GetServiceSpecs(ctx context.Context, service string) ApiGetServiceSpecsRequest {
	return ApiGetServiceSpecsRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
	}
}

// Execute executes the request
//  @return GetServiceSpecsResponse
func (a *MonitorApiService) GetServiceSpecsExecute(r ApiGetServiceSpecsRequest) (*GetServiceSpecsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetServiceSpecsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetServiceSpecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/specs"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAppointment403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceVitalsRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	history *int32
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiGetServiceVitalsRequest) History(history int32) ApiGetServiceVitalsRequest {
	r.history = &history
	return r
}

func (r ApiGetServiceVitalsRequest) XAccessToken(xAccessToken string) ApiGetServiceVitalsRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiGetServiceVitalsRequest) XSecretToken(xSecretToken string) ApiGetServiceVitalsRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiGetServiceVitalsRequest) Authorization(authorization string) ApiGetServiceVitalsRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetServiceVitalsRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiGetServiceVitalsRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiGetServiceVitalsRequest) EhelplyProject(ehelplyProject string) ApiGetServiceVitalsRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiGetServiceVitalsRequest) EhelplyData(ehelplyData string) ApiGetServiceVitalsRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiGetServiceVitalsRequest) Execute() ([]StatsVitalsResponse, *http.Response, error) {
	return r.ApiService.GetServiceVitalsExecute(r)
}

/*
GetServiceVitals Getservicevitals

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @return ApiGetServiceVitalsRequest
*/
func (a *MonitorApiService) GetServiceVitals(ctx context.Context, service string, stage string) ApiGetServiceVitalsRequest {
	return ApiGetServiceVitalsRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
	}
}

// Execute executes the request
//  @return []StatsVitalsResponse
func (a *MonitorApiService) GetServiceVitalsExecute(r ApiGetServiceVitalsRequest) ([]StatsVitalsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []StatsVitalsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetServiceVitals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/vitals"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.history != nil {
		localVarQueryParams.Add("history", parameterToString(*r.history, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServicesRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	heartbeats *bool
	heartbeatLimit *int32
	alarms *bool
	alarmLimit *int32
	includeHidden *bool
	stage *string
	key *string
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiGetServicesRequest) Heartbeats(heartbeats bool) ApiGetServicesRequest {
	r.heartbeats = &heartbeats
	return r
}

func (r ApiGetServicesRequest) HeartbeatLimit(heartbeatLimit int32) ApiGetServicesRequest {
	r.heartbeatLimit = &heartbeatLimit
	return r
}

func (r ApiGetServicesRequest) Alarms(alarms bool) ApiGetServicesRequest {
	r.alarms = &alarms
	return r
}

func (r ApiGetServicesRequest) AlarmLimit(alarmLimit int32) ApiGetServicesRequest {
	r.alarmLimit = &alarmLimit
	return r
}

func (r ApiGetServicesRequest) IncludeHidden(includeHidden bool) ApiGetServicesRequest {
	r.includeHidden = &includeHidden
	return r
}

func (r ApiGetServicesRequest) Stage(stage string) ApiGetServicesRequest {
	r.stage = &stage
	return r
}

func (r ApiGetServicesRequest) Key(key string) ApiGetServicesRequest {
	r.key = &key
	return r
}

func (r ApiGetServicesRequest) XAccessToken(xAccessToken string) ApiGetServicesRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiGetServicesRequest) XSecretToken(xSecretToken string) ApiGetServicesRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiGetServicesRequest) Authorization(authorization string) ApiGetServicesRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetServicesRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiGetServicesRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiGetServicesRequest) EhelplyProject(ehelplyProject string) ApiGetServicesRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiGetServicesRequest) EhelplyData(ehelplyData string) ApiGetServicesRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiGetServicesRequest) Execute() ([]ServiceResponse, *http.Response, error) {
	return r.ApiService.GetServicesExecute(r)
}

/*
GetServices Getservices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetServicesRequest
*/
func (a *MonitorApiService) GetServices(ctx context.Context) ApiGetServicesRequest {
	return ApiGetServicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ServiceResponse
func (a *MonitorApiService) GetServicesExecute(r ApiGetServicesRequest) ([]ServiceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ServiceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetServices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.heartbeats != nil {
		localVarQueryParams.Add("heartbeats", parameterToString(*r.heartbeats, ""))
	}
	if r.heartbeatLimit != nil {
		localVarQueryParams.Add("heartbeat_limit", parameterToString(*r.heartbeatLimit, ""))
	}
	if r.alarms != nil {
		localVarQueryParams.Add("alarms", parameterToString(*r.alarms, ""))
	}
	if r.alarmLimit != nil {
		localVarQueryParams.Add("alarm_limit", parameterToString(*r.alarmLimit, ""))
	}
	if r.includeHidden != nil {
		localVarQueryParams.Add("include_hidden", parameterToString(*r.includeHidden, ""))
	}
	if r.stage != nil {
		localVarQueryParams.Add("stage", parameterToString(*r.stage, ""))
	}
	if r.key != nil {
		localVarQueryParams.Add("key", parameterToString(*r.key, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServicesWithSpecsRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
}

func (r ApiGetServicesWithSpecsRequest) Execute() (*GetServiceServiceWithSpecsResponse, *http.Response, error) {
	return r.ApiService.GetServicesWithSpecsExecute(r)
}

/*
GetServicesWithSpecs Getserviceswithspecs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetServicesWithSpecsRequest
*/
func (a *MonitorApiService) GetServicesWithSpecs(ctx context.Context) ApiGetServicesWithSpecsRequest {
	return ApiGetServicesWithSpecsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetServiceServiceWithSpecsResponse
func (a *MonitorApiService) GetServicesWithSpecsExecute(r ApiGetServicesWithSpecsRequest) (*GetServiceServiceWithSpecsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetServiceServiceWithSpecsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetServicesWithSpecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/specs/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAppointment403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSupertackServicesRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
}

func (r ApiGetSupertackServicesRequest) Execute() ([]ServiceSuperStackMeta, *http.Response, error) {
	return r.ApiService.GetSupertackServicesExecute(r)
}

/*
GetSupertackServices Getsupertackservices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSupertackServicesRequest
*/
func (a *MonitorApiService) GetSupertackServices(ctx context.Context) ApiGetSupertackServicesRequest {
	return ApiGetSupertackServicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ServiceSuperStackMeta
func (a *MonitorApiService) GetSupertackServicesExecute(r ApiGetSupertackServicesRequest) ([]ServiceSuperStackMeta, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ServiceSuperStackMeta
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetSupertackServices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/superstack-services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHideServiceRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiHideServiceRequest) XAccessToken(xAccessToken string) ApiHideServiceRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiHideServiceRequest) XSecretToken(xSecretToken string) ApiHideServiceRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiHideServiceRequest) Authorization(authorization string) ApiHideServiceRequest {
	r.authorization = &authorization
	return r
}

func (r ApiHideServiceRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiHideServiceRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiHideServiceRequest) EhelplyProject(ehelplyProject string) ApiHideServiceRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiHideServiceRequest) EhelplyData(ehelplyData string) ApiHideServiceRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiHideServiceRequest) Execute() (*ServiceMessageResponse, *http.Response, error) {
	return r.ApiService.HideServiceExecute(r)
}

/*
HideService Hideservice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @return ApiHideServiceRequest
*/
func (a *MonitorApiService) HideService(ctx context.Context, service string, stage string) ApiHideServiceRequest {
	return ApiHideServiceRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
	}
}

// Execute executes the request
//  @return ServiceMessageResponse
func (a *MonitorApiService) HideServiceExecute(r ApiHideServiceRequest) (*ServiceMessageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceMessageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.HideService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/hide"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIgnoreAlarmRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	alarmUuid string
	alarmIgnore *AlarmIgnore
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiIgnoreAlarmRequest) AlarmIgnore(alarmIgnore AlarmIgnore) ApiIgnoreAlarmRequest {
	r.alarmIgnore = &alarmIgnore
	return r
}

func (r ApiIgnoreAlarmRequest) XAccessToken(xAccessToken string) ApiIgnoreAlarmRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiIgnoreAlarmRequest) XSecretToken(xSecretToken string) ApiIgnoreAlarmRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiIgnoreAlarmRequest) Authorization(authorization string) ApiIgnoreAlarmRequest {
	r.authorization = &authorization
	return r
}

func (r ApiIgnoreAlarmRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiIgnoreAlarmRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiIgnoreAlarmRequest) EhelplyProject(ehelplyProject string) ApiIgnoreAlarmRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiIgnoreAlarmRequest) EhelplyData(ehelplyData string) ApiIgnoreAlarmRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiIgnoreAlarmRequest) Execute() (*AlarmResponse, *http.Response, error) {
	return r.ApiService.IgnoreAlarmExecute(r)
}

/*
IgnoreAlarm Ignorealarm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @param alarmUuid
 @return ApiIgnoreAlarmRequest
*/
func (a *MonitorApiService) IgnoreAlarm(ctx context.Context, service string, stage string, alarmUuid string) ApiIgnoreAlarmRequest {
	return ApiIgnoreAlarmRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
		alarmUuid: alarmUuid,
	}
}

// Execute executes the request
//  @return AlarmResponse
func (a *MonitorApiService) IgnoreAlarmExecute(r ApiIgnoreAlarmRequest) (*AlarmResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlarmResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.IgnoreAlarm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/alarms/{alarm_uuid}/ignore"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alarm_uuid"+"}", url.PathEscape(parameterToString(r.alarmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.alarmIgnore == nil {
		return localVarReturnValue, nil, reportError("alarmIgnore is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.alarmIgnore
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegisterServiceRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	serviceCreate *ServiceCreate
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiRegisterServiceRequest) ServiceCreate(serviceCreate ServiceCreate) ApiRegisterServiceRequest {
	r.serviceCreate = &serviceCreate
	return r
}

func (r ApiRegisterServiceRequest) XAccessToken(xAccessToken string) ApiRegisterServiceRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiRegisterServiceRequest) XSecretToken(xSecretToken string) ApiRegisterServiceRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiRegisterServiceRequest) Authorization(authorization string) ApiRegisterServiceRequest {
	r.authorization = &authorization
	return r
}

func (r ApiRegisterServiceRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiRegisterServiceRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiRegisterServiceRequest) EhelplyProject(ehelplyProject string) ApiRegisterServiceRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiRegisterServiceRequest) EhelplyData(ehelplyData string) ApiRegisterServiceRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiRegisterServiceRequest) Execute() (*ServiceResponse, *http.Response, error) {
	return r.ApiService.RegisterServiceExecute(r)
}

/*
RegisterService Registerservice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRegisterServiceRequest
*/
func (a *MonitorApiService) RegisterService(ctx context.Context) ApiRegisterServiceRequest {
	return ApiRegisterServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceResponse
func (a *MonitorApiService) RegisterServiceExecute(r ApiRegisterServiceRequest) (*ServiceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.RegisterService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceCreate == nil {
		return localVarReturnValue, nil, reportError("serviceCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.serviceCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSaveServiceSuperStackMetaRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	serviceSuperStackMeta *ServiceSuperStackMeta
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiSaveServiceSuperStackMetaRequest) ServiceSuperStackMeta(serviceSuperStackMeta ServiceSuperStackMeta) ApiSaveServiceSuperStackMetaRequest {
	r.serviceSuperStackMeta = &serviceSuperStackMeta
	return r
}

func (r ApiSaveServiceSuperStackMetaRequest) XAccessToken(xAccessToken string) ApiSaveServiceSuperStackMetaRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiSaveServiceSuperStackMetaRequest) XSecretToken(xSecretToken string) ApiSaveServiceSuperStackMetaRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiSaveServiceSuperStackMetaRequest) Authorization(authorization string) ApiSaveServiceSuperStackMetaRequest {
	r.authorization = &authorization
	return r
}

func (r ApiSaveServiceSuperStackMetaRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiSaveServiceSuperStackMetaRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiSaveServiceSuperStackMetaRequest) EhelplyProject(ehelplyProject string) ApiSaveServiceSuperStackMetaRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiSaveServiceSuperStackMetaRequest) EhelplyData(ehelplyData string) ApiSaveServiceSuperStackMetaRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiSaveServiceSuperStackMetaRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.SaveServiceSuperStackMetaExecute(r)
}

/*
SaveServiceSuperStackMeta Saveservicesuperstackmeta

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @return ApiSaveServiceSuperStackMetaRequest
*/
func (a *MonitorApiService) SaveServiceSuperStackMeta(ctx context.Context, service string) ApiSaveServiceSuperStackMetaRequest {
	return ApiSaveServiceSuperStackMetaRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
	}
}

// Execute executes the request
//  @return interface{}
func (a *MonitorApiService) SaveServiceSuperStackMetaExecute(r ApiSaveServiceSuperStackMetaRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.SaveServiceSuperStackMeta")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/superstack"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceSuperStackMeta == nil {
		return localVarReturnValue, nil, reportError("serviceSuperStackMeta is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.serviceSuperStackMeta
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchAlarmsRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	page *int32
	pageSize *int32
	search *string
	searchOn *string
	sortOn *string
	sortDesc *bool
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiSearchAlarmsRequest) Page(page int32) ApiSearchAlarmsRequest {
	r.page = &page
	return r
}

func (r ApiSearchAlarmsRequest) PageSize(pageSize int32) ApiSearchAlarmsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiSearchAlarmsRequest) Search(search string) ApiSearchAlarmsRequest {
	r.search = &search
	return r
}

func (r ApiSearchAlarmsRequest) SearchOn(searchOn string) ApiSearchAlarmsRequest {
	r.searchOn = &searchOn
	return r
}

func (r ApiSearchAlarmsRequest) SortOn(sortOn string) ApiSearchAlarmsRequest {
	r.sortOn = &sortOn
	return r
}

func (r ApiSearchAlarmsRequest) SortDesc(sortDesc bool) ApiSearchAlarmsRequest {
	r.sortDesc = &sortDesc
	return r
}

func (r ApiSearchAlarmsRequest) XAccessToken(xAccessToken string) ApiSearchAlarmsRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiSearchAlarmsRequest) XSecretToken(xSecretToken string) ApiSearchAlarmsRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiSearchAlarmsRequest) Authorization(authorization string) ApiSearchAlarmsRequest {
	r.authorization = &authorization
	return r
}

func (r ApiSearchAlarmsRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiSearchAlarmsRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiSearchAlarmsRequest) EhelplyProject(ehelplyProject string) ApiSearchAlarmsRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiSearchAlarmsRequest) EhelplyData(ehelplyData string) ApiSearchAlarmsRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiSearchAlarmsRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.SearchAlarmsExecute(r)
}

/*
SearchAlarms Searchalarms

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @return ApiSearchAlarmsRequest
*/
func (a *MonitorApiService) SearchAlarms(ctx context.Context, service string) ApiSearchAlarmsRequest {
	return ApiSearchAlarmsRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
	}
}

// Execute executes the request
//  @return Page
func (a *MonitorApiService) SearchAlarmsExecute(r ApiSearchAlarmsRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.SearchAlarms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/alarms"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.searchOn != nil {
		localVarQueryParams.Add("search_on", parameterToString(*r.searchOn, ""))
	}
	if r.sortOn != nil {
		localVarQueryParams.Add("sort_on", parameterToString(*r.sortOn, ""))
	}
	if r.sortDesc != nil {
		localVarQueryParams.Add("sort_desc", parameterToString(*r.sortDesc, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShowServiceRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiShowServiceRequest) XAccessToken(xAccessToken string) ApiShowServiceRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiShowServiceRequest) XSecretToken(xSecretToken string) ApiShowServiceRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiShowServiceRequest) Authorization(authorization string) ApiShowServiceRequest {
	r.authorization = &authorization
	return r
}

func (r ApiShowServiceRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiShowServiceRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiShowServiceRequest) EhelplyProject(ehelplyProject string) ApiShowServiceRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiShowServiceRequest) EhelplyData(ehelplyData string) ApiShowServiceRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiShowServiceRequest) Execute() (*ServiceMessageResponse, *http.Response, error) {
	return r.ApiService.ShowServiceExecute(r)
}

/*
ShowService Showservice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @return ApiShowServiceRequest
*/
func (a *MonitorApiService) ShowService(ctx context.Context, service string, stage string) ApiShowServiceRequest {
	return ApiShowServiceRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
	}
}

// Execute executes the request
//  @return ServiceMessageResponse
func (a *MonitorApiService) ShowServiceExecute(r ApiShowServiceRequest) (*ServiceMessageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceMessageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.ShowService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/show"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTerminateAlarmRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	alarmUuid string
	alarmTerminate *AlarmTerminate
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiTerminateAlarmRequest) AlarmTerminate(alarmTerminate AlarmTerminate) ApiTerminateAlarmRequest {
	r.alarmTerminate = &alarmTerminate
	return r
}

func (r ApiTerminateAlarmRequest) XAccessToken(xAccessToken string) ApiTerminateAlarmRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiTerminateAlarmRequest) XSecretToken(xSecretToken string) ApiTerminateAlarmRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiTerminateAlarmRequest) Authorization(authorization string) ApiTerminateAlarmRequest {
	r.authorization = &authorization
	return r
}

func (r ApiTerminateAlarmRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiTerminateAlarmRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiTerminateAlarmRequest) EhelplyProject(ehelplyProject string) ApiTerminateAlarmRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiTerminateAlarmRequest) EhelplyData(ehelplyData string) ApiTerminateAlarmRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiTerminateAlarmRequest) Execute() (*AlarmResponse, *http.Response, error) {
	return r.ApiService.TerminateAlarmExecute(r)
}

/*
TerminateAlarm Terminatealarm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @param alarmUuid
 @return ApiTerminateAlarmRequest
*/
func (a *MonitorApiService) TerminateAlarm(ctx context.Context, service string, stage string, alarmUuid string) ApiTerminateAlarmRequest {
	return ApiTerminateAlarmRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
		alarmUuid: alarmUuid,
	}
}

// Execute executes the request
//  @return AlarmResponse
func (a *MonitorApiService) TerminateAlarmExecute(r ApiTerminateAlarmRequest) (*AlarmResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlarmResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.TerminateAlarm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/alarms/{alarm_uuid}/terminate"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alarm_uuid"+"}", url.PathEscape(parameterToString(r.alarmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.alarmTerminate == nil {
		return localVarReturnValue, nil, reportError("alarmTerminate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.alarmTerminate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTriggerAlarmRequest struct {
	ctx context.Context
	ApiService *MonitorApiService
	service string
	stage string
	alarmCreate *AlarmCreate
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiTriggerAlarmRequest) AlarmCreate(alarmCreate AlarmCreate) ApiTriggerAlarmRequest {
	r.alarmCreate = &alarmCreate
	return r
}

func (r ApiTriggerAlarmRequest) XAccessToken(xAccessToken string) ApiTriggerAlarmRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiTriggerAlarmRequest) XSecretToken(xSecretToken string) ApiTriggerAlarmRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiTriggerAlarmRequest) Authorization(authorization string) ApiTriggerAlarmRequest {
	r.authorization = &authorization
	return r
}

func (r ApiTriggerAlarmRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiTriggerAlarmRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiTriggerAlarmRequest) EhelplyProject(ehelplyProject string) ApiTriggerAlarmRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiTriggerAlarmRequest) EhelplyData(ehelplyData string) ApiTriggerAlarmRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiTriggerAlarmRequest) Execute() (*AlarmResponse, *http.Response, error) {
	return r.ApiService.TriggerAlarmExecute(r)
}

/*
TriggerAlarm Triggeralarm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param stage
 @return ApiTriggerAlarmRequest
*/
func (a *MonitorApiService) TriggerAlarm(ctx context.Context, service string, stage string) ApiTriggerAlarmRequest {
	return ApiTriggerAlarmRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		stage: stage,
	}
}

// Execute executes the request
//  @return AlarmResponse
func (a *MonitorApiService) TriggerAlarmExecute(r ApiTriggerAlarmRequest) (*AlarmResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlarmResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.TriggerAlarm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sam/monitor/services/{service}/stages/{stage}/alarms"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stage"+"}", url.PathEscape(parameterToString(r.stage, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.alarmCreate == nil {
		return localVarReturnValue, nil, reportError("alarmCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.alarmCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
