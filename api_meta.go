/*
eHelply SDK - 1.1.111

eHelply SDK for SuperStack Services

API version: 1.1.111
Contact: support@ehelply.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ehelply

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// MetaApiService MetaApi service
type MetaApiService service

type ApiCreateFieldRequest struct {
	ctx context.Context
	ApiService *MetaApiService
	field *Field
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiCreateFieldRequest) Field(field Field) ApiCreateFieldRequest {
	r.field = &field
	return r
}

func (r ApiCreateFieldRequest) XAccessToken(xAccessToken string) ApiCreateFieldRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiCreateFieldRequest) XSecretToken(xSecretToken string) ApiCreateFieldRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiCreateFieldRequest) Authorization(authorization string) ApiCreateFieldRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCreateFieldRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiCreateFieldRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiCreateFieldRequest) EhelplyProject(ehelplyProject string) ApiCreateFieldRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiCreateFieldRequest) EhelplyData(ehelplyData string) ApiCreateFieldRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiCreateFieldRequest) Execute() (*FieldDynamo, *http.Response, error) {
	return r.ApiService.CreateFieldExecute(r)
}

/*
CreateField Create Field

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFieldRequest
*/
func (a *MetaApiService) CreateField(ctx context.Context) ApiCreateFieldRequest {
	return ApiCreateFieldRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldDynamo
func (a *MetaApiService) CreateFieldExecute(r ApiCreateFieldRequest) (*FieldDynamo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldDynamo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetaApiService.CreateField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/meta/field"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.field == nil {
		return localVarReturnValue, nil, reportError("field is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.field
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMetaRequest struct {
	ctx context.Context
	ApiService *MetaApiService
	service string
	typeStr string
	entityUuid string
	metaCreate *MetaCreate
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiCreateMetaRequest) MetaCreate(metaCreate MetaCreate) ApiCreateMetaRequest {
	r.metaCreate = &metaCreate
	return r
}

func (r ApiCreateMetaRequest) XAccessToken(xAccessToken string) ApiCreateMetaRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiCreateMetaRequest) XSecretToken(xSecretToken string) ApiCreateMetaRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiCreateMetaRequest) Authorization(authorization string) ApiCreateMetaRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCreateMetaRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiCreateMetaRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiCreateMetaRequest) EhelplyProject(ehelplyProject string) ApiCreateMetaRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiCreateMetaRequest) EhelplyData(ehelplyData string) ApiCreateMetaRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiCreateMetaRequest) Execute() (*MetaDynamo, *http.Response, error) {
	return r.ApiService.CreateMetaExecute(r)
}

/*
CreateMeta Create Meta

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param typeStr
 @param entityUuid
 @return ApiCreateMetaRequest
*/
func (a *MetaApiService) CreateMeta(ctx context.Context, service string, typeStr string, entityUuid string) ApiCreateMetaRequest {
	return ApiCreateMetaRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		typeStr: typeStr,
		entityUuid: entityUuid,
	}
}

// Execute executes the request
//  @return MetaDynamo
func (a *MetaApiService) CreateMetaExecute(r ApiCreateMetaRequest) (*MetaDynamo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetaDynamo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetaApiService.CreateMeta")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/meta/meta/service/{service}/type/{type_str}/entity/{entity_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type_str"+"}", url.PathEscape(parameterToString(r.typeStr, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entity_uuid"+"}", url.PathEscape(parameterToString(r.entityUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metaCreate == nil {
		return localVarReturnValue, nil, reportError("metaCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.metaCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFieldRequest struct {
	ctx context.Context
	ApiService *MetaApiService
	fieldUuid string
	softDelete *bool
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiDeleteFieldRequest) SoftDelete(softDelete bool) ApiDeleteFieldRequest {
	r.softDelete = &softDelete
	return r
}

func (r ApiDeleteFieldRequest) XAccessToken(xAccessToken string) ApiDeleteFieldRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiDeleteFieldRequest) XSecretToken(xSecretToken string) ApiDeleteFieldRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiDeleteFieldRequest) Authorization(authorization string) ApiDeleteFieldRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteFieldRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiDeleteFieldRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiDeleteFieldRequest) EhelplyProject(ehelplyProject string) ApiDeleteFieldRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiDeleteFieldRequest) EhelplyData(ehelplyData string) ApiDeleteFieldRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiDeleteFieldRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteFieldExecute(r)
}

/*
DeleteField Delete Field

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldUuid
 @return ApiDeleteFieldRequest
*/
func (a *MetaApiService) DeleteField(ctx context.Context, fieldUuid string) ApiDeleteFieldRequest {
	return ApiDeleteFieldRequest{
		ApiService: a,
		ctx: ctx,
		fieldUuid: fieldUuid,
	}
}

// Execute executes the request
//  @return interface{}
func (a *MetaApiService) DeleteFieldExecute(r ApiDeleteFieldRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetaApiService.DeleteField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/meta/field/{field_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"field_uuid"+"}", url.PathEscape(parameterToString(r.fieldUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.softDelete != nil {
		localVarQueryParams.Add("soft_delete", parameterToString(*r.softDelete, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMetaRequest struct {
	ctx context.Context
	ApiService *MetaApiService
	service string
	typeStr string
	entityUuid string
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiDeleteMetaRequest) XAccessToken(xAccessToken string) ApiDeleteMetaRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiDeleteMetaRequest) XSecretToken(xSecretToken string) ApiDeleteMetaRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiDeleteMetaRequest) Authorization(authorization string) ApiDeleteMetaRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteMetaRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiDeleteMetaRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiDeleteMetaRequest) EhelplyProject(ehelplyProject string) ApiDeleteMetaRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiDeleteMetaRequest) EhelplyData(ehelplyData string) ApiDeleteMetaRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiDeleteMetaRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteMetaExecute(r)
}

/*
DeleteMeta Delete Meta

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param typeStr
 @param entityUuid
 @return ApiDeleteMetaRequest
*/
func (a *MetaApiService) DeleteMeta(ctx context.Context, service string, typeStr string, entityUuid string) ApiDeleteMetaRequest {
	return ApiDeleteMetaRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		typeStr: typeStr,
		entityUuid: entityUuid,
	}
}

// Execute executes the request
//  @return interface{}
func (a *MetaApiService) DeleteMetaExecute(r ApiDeleteMetaRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetaApiService.DeleteMeta")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/meta/meta/service/{service}/type/{type_str}/entity/{entity_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type_str"+"}", url.PathEscape(parameterToString(r.typeStr, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entity_uuid"+"}", url.PathEscape(parameterToString(r.entityUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMetaFromUuidRequest struct {
	ctx context.Context
	ApiService *MetaApiService
	metaUuid string
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiDeleteMetaFromUuidRequest) XAccessToken(xAccessToken string) ApiDeleteMetaFromUuidRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiDeleteMetaFromUuidRequest) XSecretToken(xSecretToken string) ApiDeleteMetaFromUuidRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiDeleteMetaFromUuidRequest) Authorization(authorization string) ApiDeleteMetaFromUuidRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteMetaFromUuidRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiDeleteMetaFromUuidRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiDeleteMetaFromUuidRequest) EhelplyProject(ehelplyProject string) ApiDeleteMetaFromUuidRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiDeleteMetaFromUuidRequest) EhelplyData(ehelplyData string) ApiDeleteMetaFromUuidRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiDeleteMetaFromUuidRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteMetaFromUuidExecute(r)
}

/*
DeleteMetaFromUuid Delete Meta From Uuid

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metaUuid
 @return ApiDeleteMetaFromUuidRequest
*/
func (a *MetaApiService) DeleteMetaFromUuid(ctx context.Context, metaUuid string) ApiDeleteMetaFromUuidRequest {
	return ApiDeleteMetaFromUuidRequest{
		ApiService: a,
		ctx: ctx,
		metaUuid: metaUuid,
	}
}

// Execute executes the request
//  @return interface{}
func (a *MetaApiService) DeleteMetaFromUuidExecute(r ApiDeleteMetaFromUuidRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetaApiService.DeleteMetaFromUuid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/meta/meta/{meta_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"meta_uuid"+"}", url.PathEscape(parameterToString(r.metaUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFieldRequest struct {
	ctx context.Context
	ApiService *MetaApiService
	fieldUuid string
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiGetFieldRequest) XAccessToken(xAccessToken string) ApiGetFieldRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiGetFieldRequest) XSecretToken(xSecretToken string) ApiGetFieldRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiGetFieldRequest) Authorization(authorization string) ApiGetFieldRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetFieldRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiGetFieldRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiGetFieldRequest) EhelplyProject(ehelplyProject string) ApiGetFieldRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiGetFieldRequest) EhelplyData(ehelplyData string) ApiGetFieldRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiGetFieldRequest) Execute() (*FieldDynamo, *http.Response, error) {
	return r.ApiService.GetFieldExecute(r)
}

/*
GetField Get Field

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldUuid
 @return ApiGetFieldRequest
*/
func (a *MetaApiService) GetField(ctx context.Context, fieldUuid string) ApiGetFieldRequest {
	return ApiGetFieldRequest{
		ApiService: a,
		ctx: ctx,
		fieldUuid: fieldUuid,
	}
}

// Execute executes the request
//  @return FieldDynamo
func (a *MetaApiService) GetFieldExecute(r ApiGetFieldRequest) (*FieldDynamo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldDynamo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetaApiService.GetField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/meta/field/{field_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"field_uuid"+"}", url.PathEscape(parameterToString(r.fieldUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetaRequest struct {
	ctx context.Context
	ApiService *MetaApiService
	service string
	typeStr string
	entityUuid string
	detailed *bool
	custom *bool
	dates *bool
	history *int32
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiGetMetaRequest) Detailed(detailed bool) ApiGetMetaRequest {
	r.detailed = &detailed
	return r
}

func (r ApiGetMetaRequest) Custom(custom bool) ApiGetMetaRequest {
	r.custom = &custom
	return r
}

func (r ApiGetMetaRequest) Dates(dates bool) ApiGetMetaRequest {
	r.dates = &dates
	return r
}

func (r ApiGetMetaRequest) History(history int32) ApiGetMetaRequest {
	r.history = &history
	return r
}

func (r ApiGetMetaRequest) XAccessToken(xAccessToken string) ApiGetMetaRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiGetMetaRequest) XSecretToken(xSecretToken string) ApiGetMetaRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiGetMetaRequest) Authorization(authorization string) ApiGetMetaRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetMetaRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiGetMetaRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiGetMetaRequest) EhelplyProject(ehelplyProject string) ApiGetMetaRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiGetMetaRequest) EhelplyData(ehelplyData string) ApiGetMetaRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiGetMetaRequest) Execute() (*MetaGet, *http.Response, error) {
	return r.ApiService.GetMetaExecute(r)
}

/*
GetMeta Get Meta

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param typeStr
 @param entityUuid
 @return ApiGetMetaRequest
*/
func (a *MetaApiService) GetMeta(ctx context.Context, service string, typeStr string, entityUuid string) ApiGetMetaRequest {
	return ApiGetMetaRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		typeStr: typeStr,
		entityUuid: entityUuid,
	}
}

// Execute executes the request
//  @return MetaGet
func (a *MetaApiService) GetMetaExecute(r ApiGetMetaRequest) (*MetaGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetaGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetaApiService.GetMeta")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/meta/meta/service/{service}/type/{type_str}/entity/{entity_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type_str"+"}", url.PathEscape(parameterToString(r.typeStr, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entity_uuid"+"}", url.PathEscape(parameterToString(r.entityUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.detailed != nil {
		localVarQueryParams.Add("detailed", parameterToString(*r.detailed, ""))
	}
	if r.custom != nil {
		localVarQueryParams.Add("custom", parameterToString(*r.custom, ""))
	}
	if r.dates != nil {
		localVarQueryParams.Add("dates", parameterToString(*r.dates, ""))
	}
	if r.history != nil {
		localVarQueryParams.Add("history", parameterToString(*r.history, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetaFromUuidRequest struct {
	ctx context.Context
	ApiService *MetaApiService
	metaUuid string
	detailed *bool
	custom *bool
	dates *bool
	history *int32
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiGetMetaFromUuidRequest) Detailed(detailed bool) ApiGetMetaFromUuidRequest {
	r.detailed = &detailed
	return r
}

func (r ApiGetMetaFromUuidRequest) Custom(custom bool) ApiGetMetaFromUuidRequest {
	r.custom = &custom
	return r
}

func (r ApiGetMetaFromUuidRequest) Dates(dates bool) ApiGetMetaFromUuidRequest {
	r.dates = &dates
	return r
}

func (r ApiGetMetaFromUuidRequest) History(history int32) ApiGetMetaFromUuidRequest {
	r.history = &history
	return r
}

func (r ApiGetMetaFromUuidRequest) XAccessToken(xAccessToken string) ApiGetMetaFromUuidRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiGetMetaFromUuidRequest) XSecretToken(xSecretToken string) ApiGetMetaFromUuidRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiGetMetaFromUuidRequest) Authorization(authorization string) ApiGetMetaFromUuidRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetMetaFromUuidRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiGetMetaFromUuidRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiGetMetaFromUuidRequest) EhelplyProject(ehelplyProject string) ApiGetMetaFromUuidRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiGetMetaFromUuidRequest) EhelplyData(ehelplyData string) ApiGetMetaFromUuidRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiGetMetaFromUuidRequest) Execute() (*MetaGet, *http.Response, error) {
	return r.ApiService.GetMetaFromUuidExecute(r)
}

/*
GetMetaFromUuid Get Meta From Uuid

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metaUuid
 @return ApiGetMetaFromUuidRequest
*/
func (a *MetaApiService) GetMetaFromUuid(ctx context.Context, metaUuid string) ApiGetMetaFromUuidRequest {
	return ApiGetMetaFromUuidRequest{
		ApiService: a,
		ctx: ctx,
		metaUuid: metaUuid,
	}
}

// Execute executes the request
//  @return MetaGet
func (a *MetaApiService) GetMetaFromUuidExecute(r ApiGetMetaFromUuidRequest) (*MetaGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetaGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetaApiService.GetMetaFromUuid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/meta/meta/{meta_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"meta_uuid"+"}", url.PathEscape(parameterToString(r.metaUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.detailed != nil {
		localVarQueryParams.Add("detailed", parameterToString(*r.detailed, ""))
	}
	if r.custom != nil {
		localVarQueryParams.Add("custom", parameterToString(*r.custom, ""))
	}
	if r.dates != nil {
		localVarQueryParams.Add("dates", parameterToString(*r.dates, ""))
	}
	if r.history != nil {
		localVarQueryParams.Add("history", parameterToString(*r.history, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMakeSlugRequest struct {
	ctx context.Context
	ApiService *MetaApiService
	metaSlugger *MetaSlugger
}

func (r ApiMakeSlugRequest) MetaSlugger(metaSlugger MetaSlugger) ApiMakeSlugRequest {
	r.metaSlugger = &metaSlugger
	return r
}

func (r ApiMakeSlugRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.MakeSlugExecute(r)
}

/*
MakeSlug Make Slug

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMakeSlugRequest
*/
func (a *MetaApiService) MakeSlug(ctx context.Context) ApiMakeSlugRequest {
	return ApiMakeSlugRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *MetaApiService) MakeSlugExecute(r ApiMakeSlugRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetaApiService.MakeSlug")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/meta/meta/slug"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metaSlugger == nil {
		return localVarReturnValue, nil, reportError("metaSlugger is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metaSlugger
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTouchMetaRequest struct {
	ctx context.Context
	ApiService *MetaApiService
	service string
	typeStr string
	entityUuid string
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiTouchMetaRequest) XAccessToken(xAccessToken string) ApiTouchMetaRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiTouchMetaRequest) XSecretToken(xSecretToken string) ApiTouchMetaRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiTouchMetaRequest) Authorization(authorization string) ApiTouchMetaRequest {
	r.authorization = &authorization
	return r
}

func (r ApiTouchMetaRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiTouchMetaRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiTouchMetaRequest) EhelplyProject(ehelplyProject string) ApiTouchMetaRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiTouchMetaRequest) EhelplyData(ehelplyData string) ApiTouchMetaRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiTouchMetaRequest) Execute() (*MetaDynamo, *http.Response, error) {
	return r.ApiService.TouchMetaExecute(r)
}

/*
TouchMeta Touch Meta

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param typeStr
 @param entityUuid
 @return ApiTouchMetaRequest
*/
func (a *MetaApiService) TouchMeta(ctx context.Context, service string, typeStr string, entityUuid string) ApiTouchMetaRequest {
	return ApiTouchMetaRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		typeStr: typeStr,
		entityUuid: entityUuid,
	}
}

// Execute executes the request
//  @return MetaDynamo
func (a *MetaApiService) TouchMetaExecute(r ApiTouchMetaRequest) (*MetaDynamo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetaDynamo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetaApiService.TouchMeta")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/meta/meta/service/{service}/type/{type_str}/entity/{entity_uuid}/touch"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type_str"+"}", url.PathEscape(parameterToString(r.typeStr, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entity_uuid"+"}", url.PathEscape(parameterToString(r.entityUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFieldRequest struct {
	ctx context.Context
	ApiService *MetaApiService
	fieldUuid string
	field *Field
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiUpdateFieldRequest) Field(field Field) ApiUpdateFieldRequest {
	r.field = &field
	return r
}

func (r ApiUpdateFieldRequest) XAccessToken(xAccessToken string) ApiUpdateFieldRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiUpdateFieldRequest) XSecretToken(xSecretToken string) ApiUpdateFieldRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiUpdateFieldRequest) Authorization(authorization string) ApiUpdateFieldRequest {
	r.authorization = &authorization
	return r
}

func (r ApiUpdateFieldRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiUpdateFieldRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiUpdateFieldRequest) EhelplyProject(ehelplyProject string) ApiUpdateFieldRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiUpdateFieldRequest) EhelplyData(ehelplyData string) ApiUpdateFieldRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiUpdateFieldRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateFieldExecute(r)
}

/*
UpdateField Update Field

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldUuid
 @return ApiUpdateFieldRequest
*/
func (a *MetaApiService) UpdateField(ctx context.Context, fieldUuid string) ApiUpdateFieldRequest {
	return ApiUpdateFieldRequest{
		ApiService: a,
		ctx: ctx,
		fieldUuid: fieldUuid,
	}
}

// Execute executes the request
//  @return interface{}
func (a *MetaApiService) UpdateFieldExecute(r ApiUpdateFieldRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetaApiService.UpdateField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/meta/field/{field_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"field_uuid"+"}", url.PathEscape(parameterToString(r.fieldUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.field == nil {
		return localVarReturnValue, nil, reportError("field is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.field
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMetaRequest struct {
	ctx context.Context
	ApiService *MetaApiService
	service string
	typeStr string
	entityUuid string
	metaCreate *MetaCreate
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiUpdateMetaRequest) MetaCreate(metaCreate MetaCreate) ApiUpdateMetaRequest {
	r.metaCreate = &metaCreate
	return r
}

func (r ApiUpdateMetaRequest) XAccessToken(xAccessToken string) ApiUpdateMetaRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiUpdateMetaRequest) XSecretToken(xSecretToken string) ApiUpdateMetaRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiUpdateMetaRequest) Authorization(authorization string) ApiUpdateMetaRequest {
	r.authorization = &authorization
	return r
}

func (r ApiUpdateMetaRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiUpdateMetaRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiUpdateMetaRequest) EhelplyProject(ehelplyProject string) ApiUpdateMetaRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiUpdateMetaRequest) EhelplyData(ehelplyData string) ApiUpdateMetaRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiUpdateMetaRequest) Execute() (*MetaDynamo, *http.Response, error) {
	return r.ApiService.UpdateMetaExecute(r)
}

/*
UpdateMeta Update Meta

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service
 @param typeStr
 @param entityUuid
 @return ApiUpdateMetaRequest
*/
func (a *MetaApiService) UpdateMeta(ctx context.Context, service string, typeStr string, entityUuid string) ApiUpdateMetaRequest {
	return ApiUpdateMetaRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		typeStr: typeStr,
		entityUuid: entityUuid,
	}
}

// Execute executes the request
//  @return MetaDynamo
func (a *MetaApiService) UpdateMetaExecute(r ApiUpdateMetaRequest) (*MetaDynamo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetaDynamo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetaApiService.UpdateMeta")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/meta/meta/service/{service}/type/{type_str}/entity/{entity_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type_str"+"}", url.PathEscape(parameterToString(r.typeStr, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entity_uuid"+"}", url.PathEscape(parameterToString(r.entityUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metaCreate == nil {
		return localVarReturnValue, nil, reportError("metaCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.metaCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMetaFromUuidRequest struct {
	ctx context.Context
	ApiService *MetaApiService
	metaUuid string
	metaCreate *MetaCreate
	xAccessToken *string
	xSecretToken *string
	authorization *string
	ehelplyActiveParticipant *string
	ehelplyProject *string
	ehelplyData *string
}

func (r ApiUpdateMetaFromUuidRequest) MetaCreate(metaCreate MetaCreate) ApiUpdateMetaFromUuidRequest {
	r.metaCreate = &metaCreate
	return r
}

func (r ApiUpdateMetaFromUuidRequest) XAccessToken(xAccessToken string) ApiUpdateMetaFromUuidRequest {
	r.xAccessToken = &xAccessToken
	return r
}

func (r ApiUpdateMetaFromUuidRequest) XSecretToken(xSecretToken string) ApiUpdateMetaFromUuidRequest {
	r.xSecretToken = &xSecretToken
	return r
}

func (r ApiUpdateMetaFromUuidRequest) Authorization(authorization string) ApiUpdateMetaFromUuidRequest {
	r.authorization = &authorization
	return r
}

func (r ApiUpdateMetaFromUuidRequest) EhelplyActiveParticipant(ehelplyActiveParticipant string) ApiUpdateMetaFromUuidRequest {
	r.ehelplyActiveParticipant = &ehelplyActiveParticipant
	return r
}

func (r ApiUpdateMetaFromUuidRequest) EhelplyProject(ehelplyProject string) ApiUpdateMetaFromUuidRequest {
	r.ehelplyProject = &ehelplyProject
	return r
}

func (r ApiUpdateMetaFromUuidRequest) EhelplyData(ehelplyData string) ApiUpdateMetaFromUuidRequest {
	r.ehelplyData = &ehelplyData
	return r
}

func (r ApiUpdateMetaFromUuidRequest) Execute() (*MetaDynamo, *http.Response, error) {
	return r.ApiService.UpdateMetaFromUuidExecute(r)
}

/*
UpdateMetaFromUuid Update Meta From Uuid

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metaUuid
 @return ApiUpdateMetaFromUuidRequest
*/
func (a *MetaApiService) UpdateMetaFromUuid(ctx context.Context, metaUuid string) ApiUpdateMetaFromUuidRequest {
	return ApiUpdateMetaFromUuidRequest{
		ApiService: a,
		ctx: ctx,
		metaUuid: metaUuid,
	}
}

// Execute executes the request
//  @return MetaDynamo
func (a *MetaApiService) UpdateMetaFromUuidExecute(r ApiUpdateMetaFromUuidRequest) (*MetaDynamo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetaDynamo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetaApiService.UpdateMetaFromUuid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/meta/meta/{meta_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"meta_uuid"+"}", url.PathEscape(parameterToString(r.metaUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metaCreate == nil {
		return localVarReturnValue, nil, reportError("metaCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAccessToken != nil {
		localVarHeaderParams["x-access-token"] = parameterToString(*r.xAccessToken, "")
	}
	if r.xSecretToken != nil {
		localVarHeaderParams["x-secret-token"] = parameterToString(*r.xSecretToken, "")
	}
	if r.authorization != nil {
		localVarHeaderParams["authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ehelplyActiveParticipant != nil {
		localVarHeaderParams["ehelply-active-participant"] = parameterToString(*r.ehelplyActiveParticipant, "")
	}
	if r.ehelplyProject != nil {
		localVarHeaderParams["ehelply-project"] = parameterToString(*r.ehelplyProject, "")
	}
	if r.ehelplyData != nil {
		localVarHeaderParams["ehelply-data"] = parameterToString(*r.ehelplyData, "")
	}
	// body params
	localVarPostBody = r.metaCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
